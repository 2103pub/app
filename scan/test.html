<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="color-scheme" content="dark">
    <title>„Éâ„Ç≠„É•„É°„É≥„Éà„Çπ„Ç≠„É£„Éä„Éº Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

```
    :root {
        --primary: #0066ff;
        --primary-dark: #0052cc;
        --success: #00cc66;
        --danger: #ff3366;
        --warning: #ffaa00;
        --bg: #0a0a0a;
        --card-bg: #1e1e1e;
        --text: #ffffff;
        --text-secondary: #a0a0a0;
        --border: #444444;
        --input-bg: #2a2a2a;
    }

    /* Âº∑Âà∂„ÉÄ„Éº„ÇØ„É¢„Éº„Éâ */
    html {
        background: var(--bg);
        color-scheme: dark;
    }

    body {
        font-family: 'Noto Sans JP', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: var(--bg) !important;
        color: var(--text) !important;
        min-height: 100vh;
        overflow-x: hidden;
        touch-action: pan-y;
    }

    .app-container {
        max-width: 100%;
        margin: 0 auto;
        padding: 12px;
    }

    header {
        background: var(--card-bg);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid var(--border);
        margin-bottom: 12px;
        position: relative;
        overflow: hidden;
    }

    header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--primary), var(--success));
    }

    h1 {
        font-size: 20px;
        font-weight: 900;
        background: linear-gradient(135deg, var(--primary), var(--success));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 4px;
        letter-spacing: -0.5px;
    }

    .subtitle {
        color: var(--text-secondary);
        font-size: 12px;
        font-weight: 500;
    }

    .camera-section {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 12px;
        border: 1px solid var(--border);
        margin-bottom: 12px;
    }

    .video-container {
        position: relative;
        width: 100%;
        background: #000;
        border-radius: 8px;
        overflow: hidden;
        margin-bottom: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    #video {
        width: 100%;
        display: block;
    }

    #canvas, #editCanvas {
        display: none;
    }

    .corner-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .flash-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: white;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.15s;
    }

    .flash-overlay.active {
        opacity: 0.9;
    }

    .controls {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin-bottom: 12px;
    }

    button {
        padding: 14px 16px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        font-family: 'Noto Sans JP', sans-serif;
        position: relative;
        overflow: hidden;
        letter-spacing: -0.3px;
        touch-action: manipulation;
    }

    button::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.4);
        transform: translate(-50%, -50%);
        transition: width 0.5s, height 0.5s;
    }

    button:active::before {
        width: 300px;
        height: 300px;
    }

    button:active {
        transform: scale(0.95);
    }

    .btn-primary {
        background: linear-gradient(135deg, var(--primary), #0080ff);
        color: white !important;
        box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
    }

    .btn-success {
        background: linear-gradient(135deg, var(--success), #00e673);
        color: white !important;
        box-shadow: 0 4px 12px rgba(0, 204, 102, 0.3);
        grid-column: 1 / -1;
        padding: 18px;
        font-size: 16px;
    }

    .btn-danger {
        background: linear-gradient(135deg, var(--danger), #ff5580);
        color: white !important;
        box-shadow: 0 4px 12px rgba(255, 51, 102, 0.3);
    }

    .btn-secondary {
        background: var(--input-bg);
        color: var(--text) !important;
        border: 1px solid var(--border);
    }

    button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none !important;
    }

    .settings-panel {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        border: 1px solid var(--border);
        margin-bottom: 12px;
    }

    .settings-panel h3 {
        margin-bottom: 16px;
        font-size: 16px;
        font-weight: 700;
        letter-spacing: -0.3px;
        color: var(--text);
    }

    .setting-group {
        margin-bottom: 20px;
    }

    .setting-group label {
        display: block;
        margin-bottom: 8px;
        color: var(--text-secondary) !important;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    input[type="range"] {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: var(--border);
        outline: none;
        -webkit-appearance: none;
        margin-bottom: 6px;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 102, 255, 0.4);
    }

    input[type="range"]::-moz-range-thumb {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 8px rgba(0, 102, 255, 0.4);
    }

    .value-display {
        text-align: right;
        color: var(--primary);
        font-size: 14px;
        font-weight: 700;
    }

    .checkbox-group {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        padding: 12px;
        background: var(--input-bg);
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.2s;
        border: 1px solid var(--border);
    }

    .checkbox-group:active {
        transform: scale(0.98);
    }

    input[type="checkbox"] {
        width: 22px;
        height: 22px;
        cursor: pointer;
        accent-color: var(--primary);
    }

    .checkbox-group label {
        margin: 0 !important;
        cursor: pointer;
        text-transform: none !important;
        color: var(--text) !important;
        font-weight: 500 !important;
        font-size: 14px !important;
    }

    .scanned-images {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        border: 1px solid var(--border);
    }

    .scanned-images h3 {
        margin-bottom: 16px;
        font-size: 16px;
        font-weight: 700;
        letter-spacing: -0.3px;
        color: var(--text);
    }

    .image-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
    }

    .scanned-item {
        position: relative;
        aspect-ratio: 3/4;
        border-radius: 8px;
        overflow: hidden;
        border: 2px solid var(--border);
        cursor: pointer;
        transition: all 0.2s;
        background: var(--input-bg);
    }

    .scanned-item:active {
        transform: scale(0.95);
        border-color: var(--primary);
    }

    .scanned-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .item-actions {
        position: absolute;
        top: 4px;
        right: 4px;
        display: flex;
        gap: 4px;
    }

    .action-btn {
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        color: white !important;
        border: none;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        transition: all 0.2s;
    }

    .action-btn:active {
        transform: scale(0.9);
        background: rgba(0, 0, 0, 0.95);
    }

    .continuous-mode-indicator {
        background: linear-gradient(135deg, var(--success), #00e673);
        color: white !important;
        padding: 10px 16px;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 12px;
        box-shadow: 0 4px 12px rgba(0, 204, 102, 0.3);
        animation: pulse-indicator 2s infinite;
    }

    @keyframes pulse-indicator {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.02); }
    }

    .pulse {
        width: 8px;
        height: 8px;
        background: white;
        border-radius: 50%;
        animation: pulse-dot 1.5s infinite;
    }

    @keyframes pulse-dot {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }

    /* Edit Modal */
    .edit-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 2000;
        align-items: center;
        justify-content: center;
        padding: 12px;
    }

    .edit-modal.active {
        display: flex;
    }

    .edit-content {
        width: 100%;
        max-width: 100%;
        height: 100%;
        background: var(--card-bg);
        border-radius: 12px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .edit-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .edit-header h2 {
        font-size: 18px;
        font-weight: 700;
        color: var(--text);
    }

    .close-btn {
        background: var(--input-bg);
        border: 1px solid var(--border);
        color: var(--text) !important;
        font-size: 28px;
        cursor: pointer;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        transition: all 0.2s;
    }

    .close-btn:active {
        transform: scale(0.9);
    }

    .edit-canvas-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
        border-radius: 8px;
        overflow: hidden;
        position: relative;
        min-height: 300px;
    }

    #editCanvas {
        max-width: 100%;
        max-height: 100%;
        display: block;
        cursor: crosshair;
        touch-action: none;
    }

    .edit-tools {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding-top: 8px;
        border-top: 1px solid var(--border);
    }

    .tool-row {
        display: flex;
        gap: 6px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }

    .tool-row::-webkit-scrollbar {
        display: none;
    }

    .tool-btn {
        padding: 10px 14px;
        background: var(--input-bg);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text) !important;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
        flex-shrink: 0;
    }

    .tool-btn:active {
        transform: scale(0.95);
    }

    .tool-btn.active {
        background: var(--primary);
        border-color: var(--primary);
        color: white !important;
    }

    .tool-btn:disabled {
        opacity: 0.3;
    }

    .status-message {
        padding: 12px 16px;
        border-radius: 8px;
        margin-bottom: 12px;
        font-size: 13px;
        font-weight: 600;
        animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .status-success {
        background: rgba(0, 204, 102, 0.15);
        color: var(--success);
        border: 1px solid var(--success);
    }

    .status-error {
        background: rgba(255, 51, 102, 0.15);
        color: var(--danger);
        border: 1px solid var(--danger);
    }

    .preview-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 1000;
        align-items: center;
        justify-content: center;
        padding: 12px;
    }

    .preview-modal.active {
        display: flex;
    }

    .preview-content {
        max-width: 100%;
        max-height: 100%;
        position: relative;
    }

    .preview-content img {
        max-width: 100%;
        max-height: 85vh;
        border-radius: 8px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    /* Âº∑Âà∂„Çπ„Çø„Ç§„É´ÈÅ©Áî® */
    body, html {
        background-color: var(--bg) !important;
        color: var(--text) !important;
    }
</style>
```

</head>
<body>
    <div class="app-container">
        <header>
            <h1>üì∏ „Éâ„Ç≠„É•„É°„É≥„Éà„Çπ„Ç≠„É£„Éä„Éº Pro</h1>
            <p class="subtitle">È´òÂìÅË≥™„Çπ„Ç≠„É£„É≥„ÉªÁ∑®ÈõÜ„Éª‰∏ÄÊã¨‰øùÂ≠ò</p>
        </header>

```
    <div id="statusMessage"></div>

    <div class="camera-section">
        <div class="video-container">
            <video id="video" autoplay playsinline></video>
            <canvas id="cornerCanvas" class="corner-overlay"></canvas>
            <div id="flashOverlay" class="flash-overlay"></div>
        </div>
        <canvas id="canvas"></canvas>

        <div id="continuousIndicator" style="display: none;" class="continuous-mode-indicator">
            <span class="pulse"></span>
            ÈÄ£Á∂öÊíÆÂΩ±„É¢„Éº„Éâ
        </div>

        <div class="controls">
            <button id="startCamera" class="btn-primary">üì∑ „Ç´„É°„É©Ëµ∑Âãï</button>
            <button id="capture" class="btn-success" disabled>üì∏ ÊíÆÂΩ±</button>
            <button id="toggleContinuous" class="btn-secondary" disabled>üîÑ ÈÄ£Á∂öÊíÆÂΩ±</button>
            <button id="batchSave" class="btn-primary" disabled>üíæ ‰∏ÄÊã¨‰øùÂ≠ò</button>
            <button id="exportPDF" class="btn-primary" disabled>üìÑ PDFÂá∫Âäõ</button>
            <button id="clearAll" class="btn-danger" disabled>üóëÔ∏è „Åô„Åπ„Å¶ÂâäÈô§</button>
        </div>
    </div>

    <div class="settings-panel">
        <h3>‚öôÔ∏è Ë®≠ÂÆö</h3>
        
        <div class="setting-group">
            <label>Êòé„Çã„Åï</label>
            <input type="range" id="brightness" min="-50" max="50" value="0">
            <div class="value-display"><span id="brightnessValue">0</span></div>
        </div>

        <div class="setting-group">
            <label>„Ç≥„É≥„Éà„É©„Çπ„Éà</label>
            <input type="range" id="contrast" min="0" max="200" value="100">
            <div class="value-display"><span id="contrastValue">100</span>%</div>
        </div>

        <div class="setting-group">
            <label>„Ç∑„É£„Éº„Éó„Éç„Çπ</label>
            <input type="range" id="sharpness" min="0" max="100" value="30">
            <div class="value-display"><span id="sharpnessValue">30</span></div>
        </div>

        <div class="setting-group">
            <div class="checkbox-group">
                <input type="checkbox" id="autoEdge" checked>
                <label for="autoEdge">Ëá™Âãï„Ç®„ÉÉ„Ç∏Ê§úÂá∫</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="glareReduction" checked>
                <label for="glareReduction">ÂèçÂ∞ÑËªΩÊ∏õ</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="grayscale">
                <label for="grayscale">„Ç∞„É¨„Éº„Çπ„Ç±„Éº„É´</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="hapticFeedback" checked>
                <label for="hapticFeedback">„Éê„Ç§„Éñ„É¨„Éº„Ç∑„Éß„É≥</label>
            </div>
        </div>

        <div class="setting-group">
            <label>ÈÄ£Á∂öÊíÆÂΩ±ÈñìÈöî</label>
            <input type="range" id="continuousInterval" min="1" max="5" value="2" step="0.5">
            <div class="value-display"><span id="intervalValue">2</span>Áßí</div>
        </div>
    </div>

    <div class="scanned-images">
        <h3>üìã „Çπ„Ç≠„É£„É≥Ê∏à„Åø (<span id="scanCount">0</span>)</h3>
        <div id="imageGrid" class="image-grid"></div>
    </div>
</div>

<!-- Edit Modal -->
<div id="editModal" class="edit-modal">
    <div class="edit-content">
        <div class="edit-header">
            <h2>‚úèÔ∏è Á∑®ÈõÜ</h2>
            <button class="close-btn" onclick="closeEditModal()">√ó</button>
        </div>
        
        <div class="edit-canvas-container" id="editCanvasContainer">
            <canvas id="editCanvas"></canvas>
        </div>

        <div class="edit-tools">
            <div class="tool-row">
                <button class="tool-btn" id="undoBtn" onclick="undoEdit()" disabled>‚Ü∂ Êàª„Çã</button>
                <button class="tool-btn" id="redoBtn" onclick="redoEdit()" disabled>‚Ü∑ ÈÄ≤„ÇÄ</button>
                <button class="tool-btn" id="cropBtn" onclick="enableCropMode()">‚úÇÔ∏è „Éà„É™„Éü„É≥„Ç∞</button>
                <button class="tool-btn" onclick="rotateImage(90)">‚Üª Âè≥ÂõûËª¢</button>
                <button class="tool-btn" onclick="rotateImage(-90)">‚Ü∫ Â∑¶ÂõûËª¢</button>
            </div>
            <div class="tool-row">
                <button class="tool-btn" onclick="applyFilter('grayscale')">‚¨õ „Ç∞„É¨„Éº</button>
                <button class="tool-btn" onclick="applyFilter('blackwhite')">‚óºÔ∏è ÁôΩÈªí</button>
                <button class="tool-btn" onclick="applyFilter('sepia')">üü§ „Çª„Éî„Ç¢</button>
                <button class="tool-btn" onclick="applyFilter('invert')">üîÑ ÂèçËª¢</button>
                <button class="tool-btn" onclick="resetEdit()">üîÑ „É™„Çª„ÉÉ„Éà</button>
            </div>
            <div class="tool-row">
                <button class="btn-success" style="flex: 1;" onclick="saveEdit()">üíæ ‰øùÂ≠ò</button>
            </div>
        </div>
    </div>
</div>

<!-- Preview Modal -->
<div id="previewModal" class="preview-modal">
    <div class="preview-content">
        <button class="close-btn" style="position: absolute; top: -50px; right: 0; background: rgba(0,0,0,0.8);" onclick="closePreview()">√ó</button>
        <img id="previewImage" src="" alt="Preview">
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
    let video, canvas, ctx, cornerCanvas, cornerCtx, editCanvas, editCtx;
    let stream = null;
    let scannedImages = [];
    let continuousMode = false;
    let continuousInterval = null;
    let currentEditIndex = -1;
    let cropMode = false;
    let cropStart = null;
    let cropEnd = null;
    let currentRotation = 0;
    let editHistory = [];
    let historyIndex = -1;

    document.addEventListener('DOMContentLoaded', () => {
        video = document.getElementById('video');
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        cornerCanvas = document.getElementById('cornerCanvas');
        cornerCtx = cornerCanvas.getContext('2d');
        editCanvas = document.getElementById('editCanvas');
        editCtx = editCanvas.getContext('2d');

        setupEventListeners();
        updateScanCount();
    });

    function setupEventListeners() {
        document.getElementById('startCamera').addEventListener('click', startCamera);
        document.getElementById('capture').addEventListener('click', captureImage);
        document.getElementById('toggleContinuous').addEventListener('click', toggleContinuousMode);
        document.getElementById('batchSave').addEventListener('click', batchSaveImages);
        document.getElementById('exportPDF').addEventListener('click', exportToPDF);
        document.getElementById('clearAll').addEventListener('click', clearAllScans);

        ['brightness', 'contrast', 'sharpness', 'continuousInterval'].forEach(id => {
            const input = document.getElementById(id);
            input.addEventListener('input', (e) => {
                const valueId = id + 'Value';
                let value = e.target.value;
                if (id === 'contrast') value += '%';
                if (id === 'continuousInterval') value += 'Áßí';
                document.getElementById(valueId).textContent = value;
            });
        });

        editCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        editCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        editCanvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        editCanvas.addEventListener('mousedown', handleMouseDown);
        editCanvas.addEventListener('mousemove', handleMouseMove);
        editCanvas.addEventListener('mouseup', handleMouseUp);

        video.addEventListener('play', () => {
            cornerCanvas.width = video.videoWidth;
            cornerCanvas.height = video.videoHeight;
            detectEdges();
        });
    }

    async function startCamera() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 }
                } 
            });
            video.srcObject = stream;
            
            document.getElementById('startCamera').disabled = true;
            document.getElementById('capture').disabled = false;
            document.getElementById('toggleContinuous').disabled = false;
            
            showStatus('„Ç´„É°„É©„ÇíËµ∑Âãï„Åó„Åæ„Åó„Åü ‚ú®', 'success');
        } catch (err) {
            showStatus('„Ç´„É°„É©„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            console.error('Error accessing camera:', err);
        }
    }

    function detectEdges() {
        if (!document.getElementById('autoEdge').checked || video.paused || video.ended) {
            requestAnimationFrame(detectEdges);
            return;
        }

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = video.videoWidth;
        tempCanvas.height = video.videoHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(video, 0, 0);

        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const corners = findDocumentCorners(imageData);

        cornerCtx.clearRect(0, 0, cornerCanvas.width, cornerCanvas.height);
        if (corners) {
            drawCorners(corners);
        }

        requestAnimationFrame(detectEdges);
    }

    function findDocumentCorners(imageData) {
        const w = imageData.width;
        const h = imageData.height;
        const margin = 0.1;
        return {
            topLeft: { x: w * margin, y: h * margin },
            topRight: { x: w * (1 - margin), y: h * margin },
            bottomRight: { x: w * (1 - margin), y: h * (1 - margin) },
            bottomLeft: { x: w * margin, y: h * (1 - margin) }
        };
    }

    function drawCorners(corners) {
        cornerCtx.strokeStyle = '#00cc66';
        cornerCtx.lineWidth = 3;
        cornerCtx.setLineDash([10, 5]);

        cornerCtx.beginPath();
        cornerCtx.moveTo(corners.topLeft.x, corners.topLeft.y);
        cornerCtx.lineTo(corners.topRight.x, corners.topRight.y);
        cornerCtx.lineTo(corners.bottomRight.x, corners.bottomRight.y);
        cornerCtx.lineTo(corners.bottomLeft.x, corners.bottomLeft.y);
        cornerCtx.closePath();
        cornerCtx.stroke();

        cornerCtx.setLineDash([]);
        cornerCtx.fillStyle = '#00cc66';
        [corners.topLeft, corners.topRight, corners.bottomRight, corners.bottomLeft].forEach(point => {
            cornerCtx.beginPath();
            cornerCtx.arc(point.x, point.y, 8, 0, Math.PI * 2);
            cornerCtx.fill();
        });
    }

    function captureImage() {
        const flash = document.getElementById('flashOverlay');
        flash.classList.add('active');
        setTimeout(() => flash.classList.remove('active'), 150);

        if (document.getElementById('hapticFeedback').checked && navigator.vibrate) {
            navigator.vibrate([30, 10, 30]);
        }

        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0);

        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        if (document.getElementById('glareReduction').checked) {
            imageData = reduceGlare(imageData);
        }

        imageData = adjustBrightnessContrast(imageData);
        
        if (document.getElementById('sharpness').value > 0) {
            imageData = applySharpen(imageData);
        }

        if (document.getElementById('grayscale').checked) {
            imageData = convertToGrayscale(imageData);
        }

        ctx.putImageData(imageData, 0, 0);

        if (document.getElementById('autoEdge').checked) {
            applyPerspectiveCorrection();
        }

        const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
        scannedImages.push(dataUrl);
        updateImageGrid();
        updateScanCount();
        
        document.getElementById('batchSave').disabled = false;
        document.getElementById('exportPDF').disabled = false;
        document.getElementById('clearAll').disabled = false;

        showStatus('üì∏ ÊíÆÂΩ±„Åó„Åæ„Åó„ÅüÔºÅ', 'success');
    }

    function reduceGlare(imageData) {
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            const brightness = (r + g + b) / 3;
            if (brightness > 200) {
                const factor = 200 / brightness;
                data[i] = Math.min(255, r * factor);
                data[i + 1] = Math.min(255, g * factor);
                data[i + 2] = Math.min(255, b * factor);
            }
        }
        
        return imageData;
    }

    function adjustBrightnessContrast(imageData) {
        const data = imageData.data;
        const brightness = parseInt(document.getElementById('brightness').value);
        const contrast = parseInt(document.getElementById('contrast').value) / 100;

        for (let i = 0; i < data.length; i += 4) {
            data[i] = clamp((data[i] - 128) * contrast + 128 + brightness);
            data[i + 1] = clamp((data[i + 1] - 128) * contrast + 128 + brightness);
            data[i + 2] = clamp((data[i + 2] - 128) * contrast + 128 + brightness);
        }

        return imageData;
    }

    function applySharpen(imageData) {
        const sharpness = parseInt(document.getElementById('sharpness').value) / 100;
        const data = imageData.data;
        const w = imageData.width;
        const h = imageData.height;
        const output = new Uint8ClampedArray(data);

        const kernel = [
            0, -sharpness, 0,
            -sharpness, 1 + 4 * sharpness, -sharpness,
            0, -sharpness, 0
        ];

        for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
                for (let c = 0; c < 3; c++) {
                    let sum = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * w + (x + kx)) * 4 + c;
                            sum += data[idx] * kernel[(ky + 1) * 3 + (kx + 1)];
                        }
                    }
                    output[(y * w + x) * 4 + c] = clamp(sum);
                }
            }
        }

        return new ImageData(output, w, h);
    }

    function convertToGrayscale(imageData) {
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
            data[i] = data[i + 1] = data[i + 2] = gray;
        }
        
        return imageData;
    }

    function applyPerspectiveCorrection() {
        const correctedCanvas = document.createElement('canvas');
        const w = canvas.width;
        const h = canvas.height;
        
        correctedCanvas.width = w * 0.8;
        correctedCanvas.height = h * 0.8;
        
        const correctedCtx = correctedCanvas.getContext('2d');
        correctedCtx.drawImage(
            canvas,
            w * 0.1, h * 0.1, w * 0.8, h * 0.8,
            0, 0, correctedCanvas.width, correctedCanvas.height
        );
        
        canvas.width = correctedCanvas.width;
        canvas.height = correctedCanvas.height;
        ctx.drawImage(correctedCanvas, 0, 0);
    }

    function toggleContinuousMode() {
        continuousMode = !continuousMode;
        const indicator = document.getElementById('continuousIndicator');
        const btn = document.getElementById('toggleContinuous');

        if (continuousMode) {
            indicator.style.display = 'inline-flex';
            btn.textContent = '‚è∏ ÂÅúÊ≠¢';
            btn.classList.remove('btn-secondary');
            btn.classList.add('btn-danger');
            startContinuousCapture();
        } else {
            indicator.style.display = 'none';
            btn.textContent = 'üîÑ ÈÄ£Á∂öÊíÆÂΩ±';
            btn.classList.remove('btn-danger');
            btn.classList.add('btn-secondary');
            stopContinuousCapture();
        }
    }

    function startContinuousCapture() {
        const interval = parseFloat(document.getElementById('continuousInterval').value) * 1000;
        continuousInterval = setInterval(() => {
            captureImage();
        }, interval);
    }

    function stopContinuousCapture() {
        if (continuousInterval) {
            clearInterval(continuousInterval);
            continuousInterval = null;
        }
    }

    function updateImageGrid() {
        const grid = document.getElementById('imageGrid');
        grid.innerHTML = '';

        scannedImages.forEach((dataUrl, index) => {
            const item = document.createElement('div');
            item.className = 'scanned-item';
            item.onclick = () => showPreview(dataUrl);

            const img = document.createElement('img');
            img.src = dataUrl;

            const actions = document.createElement('div');
            actions.className = 'item-actions';

            const editBtn = document.createElement('button');
            editBtn.className = 'action-btn';
            editBtn.innerHTML = '‚úèÔ∏è';
            editBtn.onclick = (e) => {
                e.stopPropagation();
                openEditModal(index);
            };

            const removeBtn = document.createElement('button');
            removeBtn.className = 'action-btn';
            removeBtn.innerHTML = '√ó';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                removeImage(index);
            };

            actions.appendChild(editBtn);
            actions.appendChild(removeBtn);

            item.appendChild(img);
            item.appendChild(actions);
            grid.appendChild(item);
        });
    }

    function removeImage(index) {
        scannedImages.splice(index, 1);
        updateImageGrid();
        updateScanCount();

        if (scannedImages.length === 0) {
            document.getElementById('batchSave').disabled = true;
            document.getElementById('exportPDF').disabled = true;
            document.getElementById('clearAll').disabled = true;
        }
    }

    function clearAllScans() {
        if (confirm('„Åô„Åπ„Å¶„ÅÆ„Çπ„Ç≠„É£„É≥„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
            scannedImages = [];
            updateImageGrid();
            updateScanCount();
            document.getElementById('batchSave').disabled = true;
            document.getElementById('exportPDF').disabled = true;
            document.getElementById('clearAll').disabled = true;
            showStatus('üóëÔ∏è „Åô„Åπ„Å¶ÂâäÈô§„Åó„Åæ„Åó„Åü', 'success');
        }
    }

    function updateScanCount() {
        document.getElementById('scanCount').textContent = scannedImages.length;
    }

    function openEditModal(index) {
        currentEditIndex = index;
        currentRotation = 0;
        editHistory = [];
        historyIndex = -1;
        
        const img = new Image();
        img.onload = () => {
            editCanvas.width = img.width;
            editCanvas.height = img.height;
            editCtx.drawImage(img, 0, 0);
            saveToHistory();
            document.getElementById('editModal').classList.add('active');
        };
        img.src = scannedImages[index];
    }

    function closeEditModal() {
        document.getElementById('editModal').classList.remove('active');
        cropMode = false;
        document.getElementById('cropBtn').classList.remove('active');
    }

    function saveToHistory() {
        const imageData = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
        editHistory = editHistory.slice(0, historyIndex + 1);
        editHistory.push({
            data: imageData,
            width: editCanvas.width,
            height: editCanvas.height
        });
        historyIndex++;
        if (editHistory.length > 20) {
            editHistory.shift();
            historyIndex--;
        }
        updateUndoRedoButtons();
    }

    function undoEdit() {
        if (historyIndex > 0) {
            historyIndex--;
            const state = editHistory[historyIndex];
            editCanvas.width = state.width;
            editCanvas.height = state.height;
            editCtx.putImageData(state.data, 0, 0);
            updateUndoRedoButtons();
        }
    }

    function redoEdit() {
        if (historyIndex < editHistory.length - 1) {
            historyIndex++;
            const state = editHistory[historyIndex];
            editCanvas.width = state.width;
            editCanvas.height = state.height;
            editCtx.putImageData(state.data, 0, 0);
            updateUndoRedoButtons();
        }
    }

    function updateUndoRedoButtons() {
        document.getElementById('undoBtn').disabled = historyIndex <= 0;
        document.getElementById('redoBtn').disabled = historyIndex >= editHistory.length - 1;
    }

    let touchStartPos = null;

    function handleTouchStart(e) {
        e.preventDefault();
        if (!cropMode) return;
        const touch = e.touches[0];
        const rect = editCanvas.getBoundingClientRect();
        cropStart = {
            x: (touch.clientX - rect.left) * (editCanvas.width / rect.width),
            y: (touch.clientY - rect.top) * (editCanvas.height / rect.height)
        };
        touchStartPos = cropStart;
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (!cropMode || !cropStart) return;
        const touch = e.touches[0];
        const rect = editCanvas.getBoundingClientRect();
        cropEnd = {
            x: (touch.clientX - rect.left) * (editCanvas.width / rect.width),
            y: (touch.clientY - rect.top) * (editCanvas.height / rect.height)
        };
        drawCropOverlay();
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        if (!cropMode || !cropStart || !cropEnd) return;
        applyCrop();
        cropStart = null;
        cropEnd = null;
        cropMode = false;
        document.getElementById('cropBtn').classList.remove('active');
        touchStartPos = null;
    }

    function handleMouseDown(e) {
        if (!cropMode) return;
        const rect = editCanvas.getBoundingClientRect();
        cropStart = {
            x: (e.clientX - rect.left) * (editCanvas.width / rect.width),
            y: (e.clientY - rect.top) * (editCanvas.height / rect.height)
        };
    }

    function handleMouseMove(e) {
        if (!cropMode || !cropStart) return;
        const rect = editCanvas.getBoundingClientRect();
        cropEnd = {
            x: (e.clientX - rect.left) * (editCanvas.width / rect.width),
            y: (e.clientY - rect.top) * (editCanvas.height / rect.height)
        };
        drawCropOverlay();
    }

    function handleMouseUp(e) {
        if (!cropMode || !cropStart || !cropEnd) return;
        applyCrop();
        cropStart = null;
        cropEnd = null;
        cropMode = false;
        document.getElementById('cropBtn').classList.remove('active');
    }

    function enableCropMode() {
        cropMode = !cropMode;
        const btn = document.getElementById('cropBtn');
        if (cropMode) {
            btn.classList.add('active');
            editCanvas.style.cursor = 'crosshair';
        } else {
            btn.classList.remove('active');
            editCanvas.style.cursor = 'default';
            cropStart = null;
            cropEnd = null;
        }
    }

    function drawCropOverlay() {
        const state = editHistory[historyIndex];
        editCtx.putImageData(state.data, 0, 0);
        
        if (cropStart && cropEnd) {
            const x = Math.min(cropStart.x, cropEnd.x);
            const y = Math.min(cropStart.y, cropEnd.y);
            const w = Math.abs(cropEnd.x - cropStart.x);
            const h = Math.abs(cropEnd.y - cropStart.y);

            editCtx.strokeStyle = '#0066ff';
            editCtx.lineWidth = 3;
            editCtx.setLineDash([8, 8]);
            editCtx.strokeRect(x, y, w, h);
            editCtx.setLineDash([]);
        }
    }

    function applyCrop() {
        const x = Math.min(cropStart.x, cropEnd.x);
        const y = Math.min(cropStart.y, cropEnd.y);
        const w = Math.abs(cropEnd.x - cropStart.x);
        const h = Math.abs(cropEnd.y - cropStart.y);

        if (w < 10 || h < 10) return;

        const croppedData = editCtx.getImageData(x, y, w, h);
        editCanvas.width = w;
        editCanvas.height = h;
        editCtx.putImageData(croppedData, 0, 0);
        saveToHistory();
    }

    function rotateImage(degrees) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        if (Math.abs(degrees) === 90) {
            tempCanvas.width = editCanvas.height;
            tempCanvas.height = editCanvas.width;
        } else {
            tempCanvas.width = editCanvas.width;
            tempCanvas.height = editCanvas.height;
        }

        tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
        tempCtx.rotate((degrees * Math.PI) / 180);
        tempCtx.drawImage(editCanvas, -editCanvas.width / 2, -editCanvas.height / 2);

        editCanvas.width = tempCanvas.width;
        editCanvas.height = tempCanvas.height;
        editCtx.drawImage(tempCanvas, 0, 0);
        saveToHistory();
    }

    function applyFilter(filterType) {
        const imageData = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
        const data = imageData.data;

        switch(filterType) {
            case 'grayscale':
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = data[i + 1] = data[i + 2] = gray;
                }
                break;
            case 'blackwhite':
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    const bw = gray > 128 ? 255 : 0;
                    data[i] = data[i + 1] = data[i + 2] = bw;
                }
                break;
            case 'sepia':
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                    data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                    data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
                }
                break;
            case 'invert':
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                }
                break;
        }

        editCtx.putImageData(imageData, 0, 0);
        saveToHistory();
    }

    function resetEdit() {
        const img = new Image();
        img.onload = () => {
            editCanvas.width = img.width;
            editCanvas.height = img.height;
            editCtx.drawImage(img, 0, 0);
            editHistory = [];
            historyIndex = -1;
            saveToHistory();
        };
        img.src = scannedImages[currentEditIndex];
    }

    function saveEdit() {
        scannedImages[currentEditIndex] = editCanvas.toDataURL('image/jpeg', 0.95);
        updateImageGrid();
        closeEditModal();
        showStatus('‚úÖ Á∑®ÈõÜ„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü', 'success');
        
        if (navigator.vibrate) {
            navigator.vibrate([40, 20, 40]);
        }
    }

    async function batchSaveImages() {
        const zip = new JSZip();
        const timestamp = new Date().toISOString().split('T')[0];

        scannedImages.forEach((dataUrl, index) => {
            const base64Data = dataUrl.split(',')[1];
            zip.file(`scan_${String(index + 1).padStart(3, '0')}.jpg`, base64Data, { base64: true });
        });

        const content = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `scans_${timestamp}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showStatus('üíæ ‰∏ÄÊã¨‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅ', 'success');
    }

    function showPreview(dataUrl) {
        document.getElementById('previewImage').src = dataUrl;
        document.getElementById('previewModal').classList.add('active');
    }

    function closePreview() {
        document.getElementById('previewModal').classList.remove('active');
    }

    async function exportToPDF() {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4'
        });

        for (let i = 0; i < scannedImages.length; i++) {
            if (i > 0) {
                pdf.addPage();
            }

            const img = new Image();
            img.src = scannedImages[i];
            
            await new Promise(resolve => {
                img.onload = () => {
                    const pageWidth = pdf.internal.pageSize.getWidth();
                    const pageHeight = pdf.internal.pageSize.getHeight();
                    const imgRatio = img.width / img.height;
                    const pageRatio = pageWidth / pageHeight;

                    let finalWidth, finalHeight;
                    if (imgRatio > pageRatio) {
                        finalWidth = pageWidth - 20;
                        finalHeight = finalWidth / imgRatio;
                    } else {
                        finalHeight = pageHeight - 20;
                        finalWidth = finalHeight * imgRatio;
                    }

                    const x = (pageWidth - finalWidth) / 2;
                    const y = (pageHeight - finalHeight) / 2;

                    pdf.addImage(scannedImages[i], 'JPEG', x, y, finalWidth, finalHeight);
                    resolve();
                };
            });
        }

        const timestamp = new Date().toISOString().split('T')[0];
        pdf.save(`scan_${timestamp}.pdf`);
        showStatus('üìÑ PDF„ÇíÂá∫Âäõ„Åó„Åæ„Åó„Åü', 'success');
    }

    function showStatus(message, type) {
        const statusDiv = document.getElementById('statusMessage');
        statusDiv.className = `status-message status-${type}`;
        statusDiv.textContent = message;
        statusDiv.style.display = 'block';

        setTimeout(() => {
            statusDiv.style.display = 'none';
        }, 3000);
    }

    function clamp(value) {
        return Math.max(0, Math.min(255, value));
    }

    document.getElementById('previewModal').addEventListener('click', (e) => {
        if (e.target.id === 'previewModal') {
            closePreview();
        }
    });

    document.getElementById('editModal').addEventListener('click', (e) => {
        if (e.target.id === 'editModal') {
            closeEditModal();
        }
    });
</script>
```

</body>
</html>
